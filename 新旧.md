
e-govの法令APIにより、法令を過去分も含めてXML形式で取得できるようになっています。
ある法律（例えば特許法）について、最新のものと過去のものの差分を比較して、差分をdiff表示できるようにしたいです。
ただ、法律の改正パターンはいくつかあり、条や項が追加・削除されることもあれば、条などの文章だけ変わることもあったりして、一概に法律の新旧を比較するといっても具体的にどのようなアルゴリズムで比較したらよいのかは明らかではありません。

＜前提＞
・新旧の法律はXMLデータとして提供され、どちらもXMLSchemaForJapaneseLaw_v3.xsdのスキーマに沿っています。
・比較アルゴリズムは、入力を２つの新旧XMLデータ、出力を一つのXMLデータとします。
・出力のXMLデータは、基本的にXMLSchemaForJapaneseLaw_v3.xsdのスキーマに沿ったものし、以下のような形で新旧の差分が分かるものとします。（タグにdiff属性を持たせている点とTextタグを追加する点以外はスキーマに沿ったものとなります。これにより、法律のビューワとほぼ同じビューワで差分XMLも表示できるようになります。）
（１）旧XMLデータをベースに、追加・削除されたタグがあれば、そのタグ全体にdiff="added" / diff="deleted"という属性を持たせる。
（２）既存のタグの中のテキストが修正された場合、修正されたテキスト部分を<Text diff="added"> / <Text diff="deleted">という形で囲む。

＜依頼事項＞
具体的な比較アルゴリズムについて考えてほしいです。
単純なテキスト比較であればDPマッチングで最小の距離となるマッチングを求めて差分を求めればよいですが、XML同士の比較なので、そう単純ではありません。
例えば、条や項は改正によって追加・削除があり得るので、番号がずれることがあります。その場合、違う条文番号が新旧で実質的に対応関係にあることになります。このように、条、項などの単位で何らかの距離基準に基づいて実質的な対応関係を求め、対応関係が決まったら、その中でテキストベースや自分より下層の概念同士の対応関係を求めていく・・・といったアプローチが求められると思っています。
上位のタグ同士の実質的な対応関係を求めるうえでは、そのタグ内のinnerText同士の距離を指標として用いるのが簡単かと思っています。

＜参考＞
all_xmlフォルダの中には、
${lawId}_{YYYYMMDD}_{revisionId}
という命名規則のフォルダが複数ありますが、同じlawIdであれば同じ法律であることを意味します。な
なので、同じlawIdを持つ異なるrevisionIdのフォルダの中のXMLのペアが新旧のペアということになります。



そのような変化をXMLの形で比較・検出して人に分かりやすく見せる方法がいまいち思い浮かびません。。。（両方が単純なテキストならDPマッチングでよいのでしょうが。。。）
比較や表示の手法を含めて検討・提案してください。


また、条単位での比較というのが具体的にどのようなアルゴリズムを指すのか分かりません。条の中には項や号、場合によっては表なども含まれますが、それはどのように比較するのですか？そしてどのように差分を抽出するのでしょうか？（DPマッチングであれば距離が最小となるような差分を抽出するのでしょうが・・・）

比較結果の出力は、
もととなるXMLに対して、
タグ全体が追加・削除ならタグにdiff="added" / diff="deleted"という属性を追加
タグの中のテキストが修正された場合、修正されたテキスト部分を<Text diff="added"> / <Text diff="deleted">という形で囲む
これを条以下の全てのタグに適用する
HTMLレンダリングするときは、Textタグの存在にも留意して、diff属性がある場合はその部分のHTML要素にdiff属性の内容に応じたclassを追加し、視覚的に見え消しを実現する。

=====
条番号は可変であるため、**「条番号は無視し、文章の実質的な対応関係を見つけ出す」**アプローチをとります。

Step 1: 条単位への分割・正規化 (Tokenization)
法令XMLを「条（Article）」のリストに変換します。 この際、条番号（例：「第3条」）は比較用のテキストからは除外し、純粋な条文本文（innerText）のみを抽出して比較対象とします。

List A (旧): [Art1_Text, Art2_Text, Art3_Text, ...]
List B (新): [Art1_Text, Art2'_Text, Art4_Text(元3条), ...]
Step 2: 条レベルの最適アライメント (Article-Level Alignment)
2つのリスト間の最適な対応関係を動的計画法（DP）で算出します。 これは、Gitなどで使われる「行単位のDiff」を「条単位」に適用し、かつ「完全一致」以外も許容するように拡張したものです。

類似度スコア計算:

新旧のすべての条の組み合わせについて、テキスト類似度（Jaccard係数やレーベンシュタイン距離）を計算します。
ただし、計算コスト削減のため、まずは**完全一致（Exact Match）**するペアを確定（アンカー）させ、探索範囲を絞り込むヒューリスティックを導入します。
DPマッチング (Global Alignment):

スコア行列に基づき、トータルの類似度が最大になるパス（経路）を探索します。
これにより、「条番号が変わっていても、内容が似ているもの」同士がペアとして選ばれます。
Step 3: 差分判定と詳細比較
アライメント結果に基づいて、各条の状態を分類します。

判定	条件	表示処理
完全一致 (Preserved)	対応ペアあり & テキスト完全一致	変化なしとして表示（または省略）。条番号の変化があれば注記。
変更あり (Modified)	対応ペアあり & テキスト不一致	文字単位のDiffを表示。ペアリングされたもの同士で diff-match-patch を実行。
追加 (Added)	新リストで対応ペアなし	緑色で新規追加として表示。
削除 (Deleted)	旧リストで対応ペアなし	赤色で削除として表示。
この手法により、「第3条が削除され、旧・第4条が新・第3条になった」というケースでも、旧4条と新3条の内容が一致（または近似）していれば、それらは「ペア」として認識され、「削除」などの誤判定を防ぐことができます。

1. 表（Table）や項（Paragraph）の扱い
項・号: Step 1の時点で、条の中に項や号が含まれる場合、それらをひとまとまりのテキストとして扱って類似度判定します。条レベルでのペアリングが確定した後、必要に応じて条の内部（項レベル）で再度同じロジックを再帰的に適用することも可能です（まずは条レベルで実装し、精度を見ます）。
表 (Table): 表もテキスト化して比較します。
検証計画
ケーススタディ: 条ズレの検出
シナリオ: ある条が削除され、以降の条番号がすべて繰り上がった場合。
期待動作:
削除された条だけが「削除」と判定される。
番号がズレただけの後続の条は「完全一致（または変更なし）」として判定され、不要な差分（Delete/Addの嵐）が発生しないこと。
今後のステップ
このアルゴリズムにてプロトタイプを実装し、実際の法令データで挙動を確認します。 特に「完全一致アンカー」→「隙間をDPで埋める」という2段階アプローチで、パフォーマンスと精度のバランスを取ります。

